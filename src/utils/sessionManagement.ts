/**
 * Session Management Utilities
 * Functions for managing user sessions, tracking active logins, and security monitoring
 */

import { supabase } from '@/integrations/supabase/client';
import { logAudit } from './auditLogger';
import { AuditAction } from '@/types/security';

export interface SessionInfo {
  id: string;
  user_id: string;
  user_email?: string;
  device_info: {
    browser?: string;
    os?: string;
    device?: string;
  };
  ip_address: string | null;
  location?: {
    city?: string;
    country?: string;
    timezone?: string;
  };
  created_at: string;
  last_activity: string;
  expires_at: string;
  is_active: boolean;
}

export interface SessionWithUser extends SessionInfo {
  user_email: string;
  user_role: string;
  user_name: string | null;
}

/**
 * Get all active sessions for a specific user
 */
export async function getUserSessions(userId: string): Promise<SessionInfo[]> {
  try {
    console.log(`Fetching sessions for user ${userId}`);

    const { data: sessions, error } = await supabase
      .from('user_sessions')
      .select('*')
      .eq('user_id', userId)
      .eq('is_active', true)
      .gte('expires_at', new Date().toISOString())
      .order('last_activity', { ascending: false });

    if (error) {
      console.error('Error fetching user sessions:', error);
      throw error;
    }

    console.log(`Found ${sessions?.length || 0} active sessions for user ${userId}`);
    return sessions || [];
  } catch (error) {
    console.error('Failed to get user sessions:', error);
    return [];
  }
}

/**
 * Get all active sessions across all users (admin view)
 */
export async function getAllActiveSessions(): Promise<SessionWithUser[]> {
  try {
    console.log('Fetching all active sessions');

    // Get all active sessions
    const { data: sessions, error: sessionsError } = await supabase
      .from('user_sessions')
      .select('*')
      .eq('is_active', true)
      .gte('expires_at', new Date().toISOString())
      .order('last_activity', { ascending: false });

    if (sessionsError) {
      console.error('Error fetching sessions:', sessionsError);
      throw sessionsError;
    }

    if (!sessions || sessions.length === 0) {
      console.log('No active sessions found');
      return [];
    }

    console.log(`Found ${sessions.length} active sessions`);

    // Get unique user IDs
    const userIds = [...new Set(sessions.map(s => s.user_id))];

    // Fetch user details
    const { data: profiles, error: profilesError } = await supabase
      .from('profiles')
      .select('user_id, email, full_name, role')
      .in('user_id', userIds);

    if (profilesError) {
      console.error('Error fetching profiles:', profilesError);
    }

    // Create user lookup map
    const userMap = new Map(
      profiles?.map(p => [p.user_id, p]) || []
    );

    // Combine session data with user data
    const sessionsWithUsers: SessionWithUser[] = sessions.map(session => {
      const user = userMap.get(session.user_id);
      return {
        ...session,
        user_email: user?.email || 'Unknown User',
        user_role: user?.role || 'user',
        user_name: user?.full_name || null,
      };
    });

    console.log(`Returning ${sessionsWithUsers.length} sessions with user data`);
    return sessionsWithUsers;
  } catch (error) {
    console.error('Failed to get all active sessions:', error);
    return [];
  }
}

/**
 * Create a new session for a user
 */
export async function createSession(
  userId: string,
  deviceInfo: {
    browser?: string;
    os?: string;
    device?: string;
  },
  ipAddress?: string,
  location?: {
    city?: string;
    country?: string;
    timezone?: string;
  }
): Promise<string | null> {
  try {
    console.log(`Creating session for user ${userId}`);

    // Session expires in 7 days by default
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + 7);

    // Generate a unique session token
    const sessionToken = crypto.randomUUID();

    const { data, error } = await supabase
      .from('user_sessions')
      .insert({
        user_id: userId,
        session_token: sessionToken,
        device_info: deviceInfo,
        ip_address: ipAddress || null,
        location: location || null,
        // Note: created_at should be auto-generated by database default
        last_activity: new Date().toISOString(),
        expires_at: expiresAt.toISOString(),
        is_active: true,
      })
      .select('id')
      .single();

    if (error) {
      console.error('Error creating session:', error);
      console.error('Error details:', {
        message: error.message,
        details: error.details,
        hint: error.hint,
        code: error.code,
      });
      console.error('Insert payload was:', {
        user_id: userId,
        session_token: sessionToken,
        device_info: deviceInfo,
        ip_address: ipAddress || null,
        location: location || null,
        last_activity: new Date().toISOString(),
        expires_at: expiresAt.toISOString(),
        is_active: true,
      });
      throw error;
    }

    console.log(`Successfully created session ${data.id} for user ${userId}`);

    // Log session creation
    await logAudit({
      action: AuditAction.SESSION_CREATED,
      resourceType: 'session',
      resourceId: data.id,
      metadata: {
        device_info: deviceInfo,
        ip_address: ipAddress,
        location: location,
      },
    });

    return data.id;
  } catch (error) {
    console.error('Failed to create session:', error);
    return null;
  }
}

/**
 * Update session activity timestamp
 */
export async function updateSessionActivity(sessionId: string): Promise<boolean> {
  try {
    const { error } = await supabase
      .from('user_sessions')
      .update({
        last_activity: new Date().toISOString(),
      })
      .eq('id', sessionId)
      .eq('is_active', true);

    if (error) {
      console.error('Error updating session activity:', error);
      return false;
    }

    return true;
  } catch (error) {
    console.error('Failed to update session activity:', error);
    return false;
  }
}

/**
 * Terminate a specific session
 */
export async function terminateSession(
  sessionId: string,
  reason?: string
): Promise<boolean> {
  try {
    console.log(`Terminating session ${sessionId}, reason: ${reason}`);

    // Get session details before terminating
    const { data: session } = await supabase
      .from('user_sessions')
      .select('user_id, device_info, ip_address')
      .eq('id', sessionId)
      .single();

    // Mark session as inactive
    const { error } = await supabase
      .from('user_sessions')
      .update({
        is_active: false,
        expires_at: new Date().toISOString(), // Set to now to expire immediately
      })
      .eq('id', sessionId);

    if (error) {
      console.error('Error terminating session:', error);
      throw error;
    }

    console.log(`Successfully terminated session ${sessionId}`);

    // Log session termination
    if (session) {
      await logAudit({
        action: AuditAction.SESSION_TERMINATED,
        resourceType: 'session',
        resourceId: sessionId,
        metadata: {
          reason: reason || 'Manual session termination',
          device_info: session.device_info,
          ip_address: session.ip_address,
        },
      });
    }

    return true;
  } catch (error) {
    console.error('Failed to terminate session:', error);
    return false;
  }
}

/**
 * Terminate all sessions for a specific user
 */
export async function terminateAllUserSessions(
  userId: string,
  reason?: string,
  excludeSessionId?: string
): Promise<number> {
  try {
    console.log(`Terminating all sessions for user ${userId}, reason: ${reason}`);

    // Build query
    let query = supabase
      .from('user_sessions')
      .update({
        is_active: false,
        expires_at: new Date().toISOString(),
      })
      .eq('user_id', userId)
      .eq('is_active', true);

    // Optionally exclude current session
    if (excludeSessionId) {
      query = query.neq('id', excludeSessionId);
    }

    const { data, error } = await query.select('id');

    if (error) {
      console.error('Error terminating user sessions:', error);
      throw error;
    }

    const terminatedCount = data?.length || 0;
    console.log(`Successfully terminated ${terminatedCount} sessions for user ${userId}`);

    // Log the mass termination
    await logAudit({
      action: AuditAction.LOGOUT,
      resourceType: 'user',
      resourceId: userId,
      metadata: {
        reason: reason || 'Terminated all sessions',
        sessions_terminated: terminatedCount,
        excluded_session: excludeSessionId,
      },
    });

    return terminatedCount;
  } catch (error) {
    console.error('Failed to terminate all user sessions:', error);
    return 0;
  }
}

/**
 * Clean up expired sessions
 */
export async function cleanupExpiredSessions(): Promise<number> {
  try {
    console.log('Cleaning up expired sessions');

    const { data, error } = await supabase
      .from('user_sessions')
      .update({ is_active: false })
      .eq('is_active', true)
      .lt('expires_at', new Date().toISOString())
      .select('id');

    if (error) {
      console.error('Error cleaning up expired sessions:', error);
      throw error;
    }

    const cleanedCount = data?.length || 0;
    console.log(`Successfully cleaned up ${cleanedCount} expired sessions`);

    return cleanedCount;
  } catch (error) {
    console.error('Failed to cleanup expired sessions:', error);
    return 0;
  }
}

/**
 * Get session statistics
 */
export async function getSessionStats(): Promise<{
  totalActiveSessions: number;
  uniqueActiveUsers: number;
  avgSessionsPerUser: number;
  expiringSoon: number; // Sessions expiring in next 24 hours
}> {
  try {
    // Get all active sessions
    const { data: sessions, error } = await supabase
      .from('user_sessions')
      .select('user_id, expires_at')
      .eq('is_active', true)
      .gte('expires_at', new Date().toISOString());

    if (error) {
      console.error('Error fetching session stats:', error);
      throw error;
    }

    const totalActiveSessions = sessions?.length || 0;
    const uniqueActiveUsers = new Set(sessions?.map(s => s.user_id)).size;
    const avgSessionsPerUser = uniqueActiveUsers > 0
      ? Number((totalActiveSessions / uniqueActiveUsers).toFixed(1))
      : 0;

    // Count sessions expiring in next 24 hours
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    const expiringSoon = sessions?.filter(
      s => new Date(s.expires_at) <= tomorrow
    ).length || 0;

    return {
      totalActiveSessions,
      uniqueActiveUsers,
      avgSessionsPerUser,
      expiringSoon,
    };
  } catch (error) {
    console.error('Failed to get session stats:', error);
    return {
      totalActiveSessions: 0,
      uniqueActiveUsers: 0,
      avgSessionsPerUser: 0,
      expiringSoon: 0,
    };
  }
}

/**
 * Detect suspicious sessions (multiple locations, rapid session creation)
 */
export async function detectSuspiciousSessions(): Promise<SessionWithUser[]> {
  try {
    console.log('Detecting suspicious sessions');

    // Get all active sessions
    const allSessions = await getAllActiveSessions();

    // Group sessions by user
    const sessionsByUser = new Map<string, SessionWithUser[]>();
    allSessions.forEach(session => {
      const userSessions = sessionsByUser.get(session.user_id) || [];
      userSessions.push(session);
      sessionsByUser.set(session.user_id, userSessions);
    });

    const suspicious: SessionWithUser[] = [];

    // Check for suspicious patterns
    sessionsByUser.forEach((sessions, userId) => {
      // Pattern 1: Multiple different locations
      const locations = new Set(
        sessions
          .map(s => s.location?.country)
          .filter(Boolean)
      );

      if (locations.size > 2) {
        console.log(`Suspicious: User ${userId} has sessions from ${locations.size} different countries`);
        suspicious.push(...sessions);
        return;
      }

      // Pattern 2: Too many active sessions (>5)
      if (sessions.length > 5) {
        console.log(`Suspicious: User ${userId} has ${sessions.length} active sessions`);
        suspicious.push(...sessions);
        return;
      }

      // Pattern 3: Rapid session creation (>3 in last hour)
      const oneHourAgo = new Date();
      oneHourAgo.setHours(oneHourAgo.getHours() - 1);
      const recentSessions = sessions.filter(
        s => new Date(s.created_at) > oneHourAgo
      );

      if (recentSessions.length > 3) {
        console.log(`Suspicious: User ${userId} created ${recentSessions.length} sessions in last hour`);
        suspicious.push(...recentSessions);
      }
    });

    console.log(`Found ${suspicious.length} suspicious sessions`);
    return suspicious;
  } catch (error) {
    console.error('Failed to detect suspicious sessions:', error);
    return [];
  }
}

/**
 * Get session history for a user (including terminated sessions)
 */
export async function getSessionHistory(
  userId: string,
  limit: number = 50
): Promise<SessionInfo[]> {
  try {
    const { data: sessions, error } = await supabase
      .from('user_sessions')
      .select('*')
      .eq('user_id', userId)
      .order('created_at', { ascending: false })
      .limit(limit);

    if (error) {
      console.error('Error fetching session history:', error);
      throw error;
    }

    return sessions || [];
  } catch (error) {
    console.error('Failed to get session history:', error);
    return [];
  }
}
